{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BigXML Parse big xml files and stream with ease Introduction Parsing big XML files in Python is hard. On one hand, regular XML libraries load the whole file into memory, which will crash the process if the file is too big. Other solutions such as iterparse do read the file as they parse it, but they are complex to use if you don't want to run out of memory. This is where the BigXML library shines: Works with XML files of any size No need to do memory management yourself Pythonic API (using decorators similar to what Flask does) Any stream can easily be parsed, not just files (e.g. usage with Requests ) Secure from usual attacks against XML parsers Philosophy Because it needs to be able to handle big files, BigXML parses the input streams in on pass. This means that once an XML element has been seen, you cannot go back to it. In other words, all computation for a node need to be performed when it is encountered. This library borrows ideas from event-based programming. Conceptually, you can define handlers that will react to XML elements with specific names. BigXML will then dispatch the nodes of the stream being parsed to the good handlers. As the XML document is parsed, handler of deeper nodes may yield some piece of information that will be gathered by parent handlers. At the end of the day, this produces a single generator that will be handled by your application. Tip Think big and never go backward, or you will get an exception . Installation Install BigXML with pip: $ python -m pip install bigxml Status of the project BigXML is currently in beta . It is well tested, and the API should not change drastically but breaking changes may still occur in future releases. Changes are well detailed in the changelog and the version numbering follow semver .","title":"Home"},{"location":"#bigxml","text":"Parse big xml files and stream with ease","title":"BigXML"},{"location":"#introduction","text":"Parsing big XML files in Python is hard. On one hand, regular XML libraries load the whole file into memory, which will crash the process if the file is too big. Other solutions such as iterparse do read the file as they parse it, but they are complex to use if you don't want to run out of memory. This is where the BigXML library shines: Works with XML files of any size No need to do memory management yourself Pythonic API (using decorators similar to what Flask does) Any stream can easily be parsed, not just files (e.g. usage with Requests ) Secure from usual attacks against XML parsers","title":"Introduction"},{"location":"#philosophy","text":"Because it needs to be able to handle big files, BigXML parses the input streams in on pass. This means that once an XML element has been seen, you cannot go back to it. In other words, all computation for a node need to be performed when it is encountered. This library borrows ideas from event-based programming. Conceptually, you can define handlers that will react to XML elements with specific names. BigXML will then dispatch the nodes of the stream being parsed to the good handlers. As the XML document is parsed, handler of deeper nodes may yield some piece of information that will be gathered by parent handlers. At the end of the day, this produces a single generator that will be handled by your application. Tip Think big and never go backward, or you will get an exception .","title":"Philosophy"},{"location":"#installation","text":"Install BigXML with pip: $ python -m pip install bigxml","title":"Installation"},{"location":"#status-of-the-project","text":"BigXML is currently in beta . It is well tested, and the API should not change drastically but breaking changes may still occur in future releases. Changes are well detailed in the changelog and the version numbering follow semver .","title":"Status of the project"},{"location":"decorators/","text":"Decorators The xml_handle_element and xml_handle_text functions can be used to decorate functions or classes handlers . They differ in the type of node to handle: xml_handle_element is for XML elements, and pass an XMLElement instance to the decorated function xml_handle_text is for character data (i.e. text), and pass an XMLText instance to the decorated function <p> Hello, <em> world </em> ! </p> >>> @xml_handle_text(\"p\") ... def handle_text(node): ... yield (\"text\", type(node).__name__, node.text) >>> @xml_handle_element(\"p\", \"em\") ... def handle_em(node): ... yield (\"em\", type(node).__name__, node.text) >>> with open(\"paragraph.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handle_text, handle_em): ... print(item) ('text', 'XMLText', '\\n Hello,\\n ') ('em', 'XMLElement', 'world') ('text', 'XMLText', '\\n !\\n') As you can see, no special treatment is applied to the text of XMLText items, whereas accessing the text property of an XMLElement instance tries to strip unnecessary spaces. Note that @xml_handle_text is a shortcut for @xml_handle_text() : >>> @xml_handle_element(\"p\") ... class Handler(list): ... @xml_handle_text ... @xml_handle_element(\"em\") ... def handle_text(self, node): ... self.append((type(node).__name__, node.text)) >>> with open(\"paragraph.xml\", \"rb\") as f: ... Parser(f).return_from(Handler) [('XMLText', '\\n Hello,\\n '), ('XMLElement', 'world'), ('XMLText', '\\n !\\n')]","title":"Decorators"},{"location":"decorators/#decorators","text":"The xml_handle_element and xml_handle_text functions can be used to decorate functions or classes handlers . They differ in the type of node to handle: xml_handle_element is for XML elements, and pass an XMLElement instance to the decorated function xml_handle_text is for character data (i.e. text), and pass an XMLText instance to the decorated function <p> Hello, <em> world </em> ! </p> >>> @xml_handle_text(\"p\") ... def handle_text(node): ... yield (\"text\", type(node).__name__, node.text) >>> @xml_handle_element(\"p\", \"em\") ... def handle_em(node): ... yield (\"em\", type(node).__name__, node.text) >>> with open(\"paragraph.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handle_text, handle_em): ... print(item) ('text', 'XMLText', '\\n Hello,\\n ') ('em', 'XMLElement', 'world') ('text', 'XMLText', '\\n !\\n') As you can see, no special treatment is applied to the text of XMLText items, whereas accessing the text property of an XMLElement instance tries to strip unnecessary spaces. Note that @xml_handle_text is a shortcut for @xml_handle_text() : >>> @xml_handle_element(\"p\") ... class Handler(list): ... @xml_handle_text ... @xml_handle_element(\"em\") ... def handle_text(self, node): ... self.append((type(node).__name__, node.text)) >>> with open(\"paragraph.xml\", \"rb\") as f: ... Parser(f).return_from(Handler) [('XMLText', '\\n Hello,\\n '), ('XMLElement', 'world'), ('XMLText', '\\n !\\n')]","title":"Decorators"},{"location":"encodings/","text":"Stream encodings The streams passed to Parser are expected to be bytes -oriented. The decoding is performed according to the XML specification , i.e. based on the encoding attribute of the XML declaration: <?xml version='1.0' encoding='ISO-8859-1'?> Note The XML declaration is optional for UTF-8 and UTF-16 encodings. Wrong encoding Sometimes, the encoding of the stream to parse does not match the one specified in the XML declaration. >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> stream_bytes = b\"<root>\\xe0\\xe9\\xef\\xf4\\xf9</root>\" # ISO-8859-1 >>> Parser(stream_bytes).return_from(handler) Traceback (most recent call last): ... xml.etree.ElementTree.ParseError: not well-formed (invalid token)... If you know that there is no XML declaration, you can add one before the stream: >>> Parser( ... \"<?xml version='1.0' encoding='ISO-8859-1'?>\".encode(\"ISO-8859-1\"), ... stream_bytes, ... ).return_from(handler) '\u00e0\u00e9\u00ef\u00f4\u00f9' But if the XML declaration is already here, you will need to change the encoding of your stream manually. For bytes instances, decode then encode: >>> stream_bytes_with_xml_declaration = ( ... b\"<?xml version='1.0' encoding='UTF-8'?>\" # wrong encoding specified ... b\"<root>\\xe0\\xe9\\xef\\xf4\\xf9</root>\" # ISO-8859-1 ... ) >>> Parser( ... stream_bytes_with_xml_declaration.decode(\"ISO-8859-1\").encode(\"UTF-8\"), ... ).return_from(handler) '\u00e0\u00e9\u00ef\u00f4\u00f9' For file-like objects, use codecs.EncodedFile : >>> import io >>> stream_file = io.BytesIO(stream_bytes_with_xml_declaration) >>> import codecs >>> Parser( ... codecs.EncodedFile(stream_file, \"UTF-8\", \"ISO-8859-1\"), ... ).return_from(handler) '\u00e0\u00e9\u00ef\u00f4\u00f9'","title":"Encodings"},{"location":"encodings/#stream-encodings","text":"The streams passed to Parser are expected to be bytes -oriented. The decoding is performed according to the XML specification , i.e. based on the encoding attribute of the XML declaration: <?xml version='1.0' encoding='ISO-8859-1'?> Note The XML declaration is optional for UTF-8 and UTF-16 encodings.","title":"Stream encodings"},{"location":"encodings/#wrong-encoding","text":"Sometimes, the encoding of the stream to parse does not match the one specified in the XML declaration. >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> stream_bytes = b\"<root>\\xe0\\xe9\\xef\\xf4\\xf9</root>\" # ISO-8859-1 >>> Parser(stream_bytes).return_from(handler) Traceback (most recent call last): ... xml.etree.ElementTree.ParseError: not well-formed (invalid token)... If you know that there is no XML declaration, you can add one before the stream: >>> Parser( ... \"<?xml version='1.0' encoding='ISO-8859-1'?>\".encode(\"ISO-8859-1\"), ... stream_bytes, ... ).return_from(handler) '\u00e0\u00e9\u00ef\u00f4\u00f9' But if the XML declaration is already here, you will need to change the encoding of your stream manually. For bytes instances, decode then encode: >>> stream_bytes_with_xml_declaration = ( ... b\"<?xml version='1.0' encoding='UTF-8'?>\" # wrong encoding specified ... b\"<root>\\xe0\\xe9\\xef\\xf4\\xf9</root>\" # ISO-8859-1 ... ) >>> Parser( ... stream_bytes_with_xml_declaration.decode(\"ISO-8859-1\").encode(\"UTF-8\"), ... ).return_from(handler) '\u00e0\u00e9\u00ef\u00f4\u00f9' For file-like objects, use codecs.EncodedFile : >>> import io >>> stream_file = io.BytesIO(stream_bytes_with_xml_declaration) >>> import codecs >>> Parser( ... codecs.EncodedFile(stream_file, \"UTF-8\", \"ISO-8859-1\"), ... ).return_from(handler) '\u00e0\u00e9\u00ef\u00f4\u00f9'","title":"Wrong encoding"},{"location":"faq/","text":"Frequently Asked Questions What does opening a file in binary mode means? By default, when you call open(\"filename.xml\") , the file is open in text mode. In this mode, the contents of the file are returned as strings: the bytes are decoded on the fly. However, BigXML needs bytes -oriented streams , so you need to open the file in binary mode by explicitly specifying it: open(\"filename.xml\", \"rb\") . <root>Hello, world!</root> >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> # BAD >>> with open(\"hello.xml\") as f: ... Parser(f).return_from(handler) Traceback (most recent call last): ... TypeError: Stream read method returned a str, not a bytes-like object. Open file objects in binary mode. >>> # GOOD >>> with open(\"hello.xml\", \"rb\") as f: ... Parser(f).return_from(handler) 'Hello, world!' How can I parse a string? Just convert str into bytes using .encode or codecs.encode : >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text ... >>> stream_str = \"<root>Hello, world!</root>\" >>> # BAD >>> Parser(stream_str).return_from(handler) Traceback (most recent call last): ... TypeError: Invalid stream type: str. Convert it to a bytes-like object by encoding it. >>> # GOOD >>> Parser(stream_str.encode()).return_from(handler) 'Hello, world!' Tip Read the error message! I keep getting the following exception: Tried to access a node out of order Each byte of the XML streams is only read once. This exception occurs when you try to perform an action that would need to go backward in the streams. For more details, read the philosophy paragraph . Usually, the issue can be solved by following these principles: Consider that all children of a node must be processed in one pass; You usually want to handle an XMLElement instance as soon as you receive it; The text property of a XMLElement node needs to access all its children, so using it prevents you from calling iter_from and return_from on the same node. For example, consider the following problematic code: <user> <firstname>Alice</firstname> <lastname>Cooper</lastname> </user> >>> @xml_handle_element(\"firstname\") ... def handle_firstname(node): ... yield node.text >>> @xml_handle_element(\"lastname\") ... def handle_lastname(node): ... yield node.text >>> @xml_handle_element(\"user\") ... def handle_user(node): ... firstname = node.return_from(handle_firstname) ... lastname = node.return_from(handle_lastname) ... yield f\"{firstname} {lastname}\" >>> with open(\"user.xml\", \"rb\") as f: ... Parser(f).return_from(handle_user) Traceback (most recent call last): ... RuntimeError: Tried to access a node out of order The issue occurred because the children of the user node are read twice: A first time to obtain a firstname child; A second time to obtain a lastname child. Instead, we need to consider the firstname and lastname children at the same time: >>> @xml_handle_element(\"user\") ... def handle_user(node): ... names = {} ... for child_node in node.iter_from(\"firstname\", \"lastname\"): ... names[child_node.name] = child_node.text ... yield f\"{names['firstname']} {names['lastname']}\" >>> with open(\"user.xml\", \"rb\") as f: ... Parser(f).return_from(handle_user) 'Alice Cooper' The code above is hardly readable, you probably want to use a class handler instead: >>> from dataclasses import dataclass >>> @xml_handle_element(\"user\") ... @dataclass ... class User: ... firstname: str = 'N/A' ... lastname: str = 'N/A' ... ... @xml_handle_element(\"firstname\") ... def handle_firstname(self, node): ... self.firstname = node.text ... ... @xml_handle_element(\"lastname\") ... def handle_lastname(self, node): ... self.lastname = node.text ... ... def xml_handler(self): ... yield f\"{self.firstname} {self.lastname}\" >>> with open(\"user.xml\", \"rb\") as f: ... Parser(f).return_from(User) 'Alice Cooper' I have an other issue, or a feature request By all means, open an issue on GitHub!","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#parse-file-binary","text":"By default, when you call open(\"filename.xml\") , the file is open in text mode. In this mode, the contents of the file are returned as strings: the bytes are decoded on the fly. However, BigXML needs bytes -oriented streams , so you need to open the file in binary mode by explicitly specifying it: open(\"filename.xml\", \"rb\") . <root>Hello, world!</root> >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> # BAD >>> with open(\"hello.xml\") as f: ... Parser(f).return_from(handler) Traceback (most recent call last): ... TypeError: Stream read method returned a str, not a bytes-like object. Open file objects in binary mode. >>> # GOOD >>> with open(\"hello.xml\", \"rb\") as f: ... Parser(f).return_from(handler) 'Hello, world!'","title":"What does opening a file in binary mode means?"},{"location":"faq/#parse-str","text":"Just convert str into bytes using .encode or codecs.encode : >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text ... >>> stream_str = \"<root>Hello, world!</root>\" >>> # BAD >>> Parser(stream_str).return_from(handler) Traceback (most recent call last): ... TypeError: Invalid stream type: str. Convert it to a bytes-like object by encoding it. >>> # GOOD >>> Parser(stream_str.encode()).return_from(handler) 'Hello, world!' Tip Read the error message!","title":"How can I parse a string?"},{"location":"faq/#exnodes-out-of-order-exception","text":"Each byte of the XML streams is only read once. This exception occurs when you try to perform an action that would need to go backward in the streams. For more details, read the philosophy paragraph . Usually, the issue can be solved by following these principles: Consider that all children of a node must be processed in one pass; You usually want to handle an XMLElement instance as soon as you receive it; The text property of a XMLElement node needs to access all its children, so using it prevents you from calling iter_from and return_from on the same node. For example, consider the following problematic code: <user> <firstname>Alice</firstname> <lastname>Cooper</lastname> </user> >>> @xml_handle_element(\"firstname\") ... def handle_firstname(node): ... yield node.text >>> @xml_handle_element(\"lastname\") ... def handle_lastname(node): ... yield node.text >>> @xml_handle_element(\"user\") ... def handle_user(node): ... firstname = node.return_from(handle_firstname) ... lastname = node.return_from(handle_lastname) ... yield f\"{firstname} {lastname}\" >>> with open(\"user.xml\", \"rb\") as f: ... Parser(f).return_from(handle_user) Traceback (most recent call last): ... RuntimeError: Tried to access a node out of order The issue occurred because the children of the user node are read twice: A first time to obtain a firstname child; A second time to obtain a lastname child. Instead, we need to consider the firstname and lastname children at the same time: >>> @xml_handle_element(\"user\") ... def handle_user(node): ... names = {} ... for child_node in node.iter_from(\"firstname\", \"lastname\"): ... names[child_node.name] = child_node.text ... yield f\"{names['firstname']} {names['lastname']}\" >>> with open(\"user.xml\", \"rb\") as f: ... Parser(f).return_from(handle_user) 'Alice Cooper' The code above is hardly readable, you probably want to use a class handler instead: >>> from dataclasses import dataclass >>> @xml_handle_element(\"user\") ... @dataclass ... class User: ... firstname: str = 'N/A' ... lastname: str = 'N/A' ... ... @xml_handle_element(\"firstname\") ... def handle_firstname(self, node): ... self.firstname = node.text ... ... @xml_handle_element(\"lastname\") ... def handle_lastname(self, node): ... self.lastname = node.text ... ... def xml_handler(self): ... yield f\"{self.firstname} {self.lastname}\" >>> with open(\"user.xml\", \"rb\") as f: ... Parser(f).return_from(User) 'Alice Cooper'","title":"I keep getting the following exception: Tried to access a node out of order"},{"location":"faq/#i-have-an-other-issue-or-a-feature-request","text":"By all means, open an issue on GitHub!","title":"I have an other issue, or a feature request"},{"location":"handlers/","text":"Handlers The methods iter_from and return_from take handlers as arguments. Functions A handler can be a generator function taking a node as an argument. Such functions are usually decorated with xml_handle_element or xml_handle_text , to restrict the type of nodes they are called with. <inventory> <book>9780261103573</book> <lego ean=\"5702014975200\">79005</lego> <dvd>0883929452996</dvd> </inventory> >>> @xml_handle_element(\"inventory\", \"book\") ... @xml_handle_element(\"inventory\", \"dvd\") ... def handle_ean(node): ... yield (node.text, node.name) >>> @xml_handle_element(\"inventory\", \"lego\") ... def handle_lego(node): ... yield (node.attributes[\"ean\"], \"toy\") >>> with open(\"inventory.xml\", \"rb\") as stream: ... for ean, kind in Parser(stream).iter_from(handle_ean, handle_lego): ... print(f\"{ean} ({kind})\") 9780261103573 (book) 5702014975200 (toy) 0883929452996 (dvd) Note To handle different kind of nodes, the same function can be decorated several times with xml_handle_element or xml_handle_text as shown above. Classes Passing a class as a handler is a good way to group the handling of a node and its children. Note Although not mandatory, using a dataclass sometimes feels quite natural. See this recipe for more information on this use case. Let's parse the following XML file: <root> <cart user=\"Alice\"> <product price=\"7.35\">9781846975769</product> <product price=\"2.12\">9780008322052</product> </cart> <cart user=\"Bob\"> <product price=\"4.99\">9780008117498</product> <product price=\"8.14\">9780340960196</product> <product price=\"7.37\">9780099580485</product> </cart> </root> Class instantiation The class is instantiated automatically when a matching node is encountered: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... pass >>> with open(\"carts.xml\", \"rb\") as stream: ... for instance in Parser(stream).iter_from(Cart): ... print(instance) <__main__.Cart object...> <__main__.Cart object...> If your class has an __init__ method taking one mandatory parameter as argument, that argument is supplied with the encountered node: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... self.user = node.attributes[\"user\"] >>> with open(\"carts.xml\", \"rb\") as stream: ... for instance in Parser(stream).iter_from(Cart): ... print(f\"{instance} for user {instance.user}\") <__main__.Cart object...> for user Alice <__main__.Cart object...> for user Bob Class methods as sub-handlers The methods decorated with xml_handle_element or xml_handle_text are used as sub-handlers: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self): ... self.price = 0.0 ... ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... self.price += float(node.attributes[\"price\"]) >>> with open(\"carts.xml\", \"rb\") as stream: ... for instance in Parser(stream).iter_from(Cart): ... print(f\"{instance} total {instance.price:.2f}\") <__main__.Cart object...> total 9.47 <__main__.Cart object...> total 20.50 Note If such a class method yields some items, they are ignored and a warning message is issued. This behavior can be changed as explained below. Changing yielded items As seen above, the class handler yields the class instance. This default behavior can be changed by implementing an xml_handler method: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... self.user = node.attributes[\"user\"] ... self.price = 0.0 ... ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... self.price += float(node.attributes[\"price\"]) ... ... def xml_handler(self): ... yield (self.user, self.price) >>> with open(\"carts.xml\", \"rb\") as stream: ... for user, price in Parser(stream).iter_from(Cart): ... print(f\"{user} total {price:.2f}\") Alice total 9.47 Bob total 20.50 You can add a single mandatory parameter to xml_handler . In that case, it will be an iterable whose items are yielded by the sub-handlers. We can rewrite a previous example to leverage this behavior: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... yield float(node.attributes[\"price\"]) ... ... def xml_handler(self, iterable): ... yield sum(iterable) >>> with open(\"carts.xml\", \"rb\") as stream: ... for price in Parser(stream).iter_from(Cart): ... print(price) 9.47 20.50 Warning The children of the node handled by the class instance are parsed as the same time as the iterable is being iterated over. It is up to you to consume the iterable and consider the side-effects your methods may have. See also Read this recipe if you want to yield some items in the __init__ method Another recipe discusses usage with dataclasses Syntactic sugar To avoid creating a handler that simply yields the node, the following handler types are available: tuple of str / list of str (\"html\", \"body\", \"p\") is equivalent to the following handler: @xml_handle_element(\"html\", \"body\", \"p\") def handler(node): yield node str \"p\" is equivalent to [\"p\"] or the following handler: @xml_handle_element(\"p\") def handler(node): yield node This allows to quickly iterate over a specific type of children of the current node: >>> @xml_handle_element(\"root\", \"cart\") ... def handler(node): ... yield ( ... node.attributes[\"user\"], ... sum( ... float(subnode.attributes[\"price\"]) ... for subnode in node.iter_from(\"product\") ... ) ... ) >>> with open(\"carts.xml\", \"rb\") as stream: ... for user, price in Parser(stream).iter_from(handler): ... print(f\"{user} total {price:.2f}\") Alice total 9.47 Bob total 20.50","title":"Handlers"},{"location":"handlers/#handlers","text":"The methods iter_from and return_from take handlers as arguments.","title":"Handlers"},{"location":"handlers/#functions","text":"A handler can be a generator function taking a node as an argument. Such functions are usually decorated with xml_handle_element or xml_handle_text , to restrict the type of nodes they are called with. <inventory> <book>9780261103573</book> <lego ean=\"5702014975200\">79005</lego> <dvd>0883929452996</dvd> </inventory> >>> @xml_handle_element(\"inventory\", \"book\") ... @xml_handle_element(\"inventory\", \"dvd\") ... def handle_ean(node): ... yield (node.text, node.name) >>> @xml_handle_element(\"inventory\", \"lego\") ... def handle_lego(node): ... yield (node.attributes[\"ean\"], \"toy\") >>> with open(\"inventory.xml\", \"rb\") as stream: ... for ean, kind in Parser(stream).iter_from(handle_ean, handle_lego): ... print(f\"{ean} ({kind})\") 9780261103573 (book) 5702014975200 (toy) 0883929452996 (dvd) Note To handle different kind of nodes, the same function can be decorated several times with xml_handle_element or xml_handle_text as shown above.","title":"Functions"},{"location":"handlers/#classes","text":"Passing a class as a handler is a good way to group the handling of a node and its children. Note Although not mandatory, using a dataclass sometimes feels quite natural. See this recipe for more information on this use case. Let's parse the following XML file: <root> <cart user=\"Alice\"> <product price=\"7.35\">9781846975769</product> <product price=\"2.12\">9780008322052</product> </cart> <cart user=\"Bob\"> <product price=\"4.99\">9780008117498</product> <product price=\"8.14\">9780340960196</product> <product price=\"7.37\">9780099580485</product> </cart> </root>","title":"Classes"},{"location":"handlers/#class-instantiation","text":"The class is instantiated automatically when a matching node is encountered: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... pass >>> with open(\"carts.xml\", \"rb\") as stream: ... for instance in Parser(stream).iter_from(Cart): ... print(instance) <__main__.Cart object...> <__main__.Cart object...> If your class has an __init__ method taking one mandatory parameter as argument, that argument is supplied with the encountered node: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... self.user = node.attributes[\"user\"] >>> with open(\"carts.xml\", \"rb\") as stream: ... for instance in Parser(stream).iter_from(Cart): ... print(f\"{instance} for user {instance.user}\") <__main__.Cart object...> for user Alice <__main__.Cart object...> for user Bob","title":"Class instantiation"},{"location":"handlers/#class-methods-as-sub-handlers","text":"The methods decorated with xml_handle_element or xml_handle_text are used as sub-handlers: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self): ... self.price = 0.0 ... ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... self.price += float(node.attributes[\"price\"]) >>> with open(\"carts.xml\", \"rb\") as stream: ... for instance in Parser(stream).iter_from(Cart): ... print(f\"{instance} total {instance.price:.2f}\") <__main__.Cart object...> total 9.47 <__main__.Cart object...> total 20.50 Note If such a class method yields some items, they are ignored and a warning message is issued. This behavior can be changed as explained below.","title":"Class methods as sub-handlers"},{"location":"handlers/#changing-yielded-items","text":"As seen above, the class handler yields the class instance. This default behavior can be changed by implementing an xml_handler method: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... self.user = node.attributes[\"user\"] ... self.price = 0.0 ... ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... self.price += float(node.attributes[\"price\"]) ... ... def xml_handler(self): ... yield (self.user, self.price) >>> with open(\"carts.xml\", \"rb\") as stream: ... for user, price in Parser(stream).iter_from(Cart): ... print(f\"{user} total {price:.2f}\") Alice total 9.47 Bob total 20.50 You can add a single mandatory parameter to xml_handler . In that case, it will be an iterable whose items are yielded by the sub-handlers. We can rewrite a previous example to leverage this behavior: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... yield float(node.attributes[\"price\"]) ... ... def xml_handler(self, iterable): ... yield sum(iterable) >>> with open(\"carts.xml\", \"rb\") as stream: ... for price in Parser(stream).iter_from(Cart): ... print(price) 9.47 20.50 Warning The children of the node handled by the class instance are parsed as the same time as the iterable is being iterated over. It is up to you to consume the iterable and consider the side-effects your methods may have. See also Read this recipe if you want to yield some items in the __init__ method Another recipe discusses usage with dataclasses","title":"Changing yielded items"},{"location":"handlers/#syntactic-sugar","text":"To avoid creating a handler that simply yields the node, the following handler types are available: tuple of str / list of str (\"html\", \"body\", \"p\") is equivalent to the following handler: @xml_handle_element(\"html\", \"body\", \"p\") def handler(node): yield node str \"p\" is equivalent to [\"p\"] or the following handler: @xml_handle_element(\"p\") def handler(node): yield node This allows to quickly iterate over a specific type of children of the current node: >>> @xml_handle_element(\"root\", \"cart\") ... def handler(node): ... yield ( ... node.attributes[\"user\"], ... sum( ... float(subnode.attributes[\"price\"]) ... for subnode in node.iter_from(\"product\") ... ) ... ) >>> with open(\"carts.xml\", \"rb\") as stream: ... for user, price in Parser(stream).iter_from(handler): ... print(f\"{user} total {price:.2f}\") Alice total 9.47 Bob total 20.50","title":"Syntactic sugar"},{"location":"namespaces/","text":"Namespaces In XML, namespaces allow to differentiate between elements or attributes that would have the same name otherwise. General case In most cases, you don't want to care about namespaces when parsing some XML. When you see foo:bar in XML elements or attributes, do as if the foo: prefix was not here, and everything should work as expected: <root xmlns:xs=\"http://example.com/xml/schema\"> <xs:item xs:type=\"text\">Hello, world!</xs:item> </root> >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield (node.attributes[\"type\"], node.text) >>> with open(\"hello_ns.xml\", \"rb\") as f: ... Parser(f).return_from(handler) ('text', 'Hello, world!') Namespaced elements If you want to differentiate between XML elements with the same name but different namespaces, you need to mention namespaces in the handlers using the Clark notation . When parsing an XML element of name bar and namespace http://example.com/xml/schema , BigXML looks for a handler in the following order: {http://example.com/xml/schema}bar : a handler for the specific namespace bar : a handler that does not specify the namespace No handler is used, the element is ignored Tip To match only XML elements of name bar that do not have any namespace, use the following: {}bar . Example: <root xmlns=\"http://example.com/xml/purple\" xmlns:blue=\"http://example.com/xml/blue\" xmlns:red=\"http://example.com/xml/red\"> <blue:item>Blue</blue:item> <item xmlns=\"http://example.com/xml/blue\">Also blue</item> <red:item>Red</red:item> <item>Purple</item> </root> >>> @xml_handle_element(\"root\", \"item\") ... def handler_default(node): ... yield (\"default\", node.text) >>> @xml_handle_element(\"root\", \"{}item\") ... def handler_nothing(node): ... yield (\"nothing\", node.text) >>> @xml_handle_element(\"root\", \"{http://example.com/xml/blue}item\") ... def handler_blue(node): ... yield (\"blue\", node.text) >>> @xml_handle_element(\"root\", \"{http://example.com/xml/purple}item\") ... def handler_purple(node): ... yield (\"purple\", node.text) >>> with open(\"colors.xml\", \"rb\") as f: ... for item in Parser(f).iter_from( ... handler_default, ... handler_nothing, ... handler_blue, ... handler_purple, ... ): ... print(item) ('blue', 'Blue') ('blue', 'Also blue') ('default', 'Red') ('purple', 'Purple') Note In the example above, handler_purple is used instead of handler_nothing for the item Purple because a default namespace has been attached to <root> with the attribute xmlns . Namespaced attributes When accessing the attributes of a node, you can use one of the following keys: {http://example.com/xml/schema}bar to get the attribute bar with the namespace http://example.com/xml/schema ; {}bar to get the attribute bar without any namespace; bar to get an attribute bar of any namespace. Warning The bar syntax always returns the attribute bar without any namespace if it exists. However, if such an attribute does not exist but several attributes bar with various namespaces do exist, one of them will be returned. In that case, which attribute is returned is not guaranteed, and a warning is emitted accordingly. Example: <root xmlns=\"http://example.com/xml/purple\" xmlns:blue=\"http://example.com/xml/blue\" xmlns:red=\"http://example.com/xml/red\"> <item color=\"Green\">Case 0</item> <item blue:color=\"Blue\">Case 1</item> <item red:color=\"Red\">Case 2</item> <item color=\"Green\" blue:color=\"Blue\" red:color=\"Red\">Case 3</item> </root> >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield node.text ... yield (\"default ns\", node.attributes[\"color\"]) ... yield (\"no ns\", node.attributes.get(\"{}color\")) ... yield (\"blue ns\", node.attributes.get(\"{http://example.com/xml/blue}color\")) >>> with open(\"attributes_ns.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handler): ... print(item) Case 0 ('default ns', 'Green') ('no ns', 'Green') ('blue ns', None) Case 1 ('default ns', 'Blue') ('no ns', None) ('blue ns', 'Blue') Case 2 ('default ns', 'Red') ('no ns', None) ('blue ns', None) Case 3 ('default ns', 'Green') ('no ns', 'Green') ('blue ns', 'Blue') Note Contrary to XML elements, no default namespace apply to attributes: in the example, Green is matched by {}color instead of {http://example.com/xml/purple}color .","title":"Namespaces"},{"location":"namespaces/#namespaces","text":"In XML, namespaces allow to differentiate between elements or attributes that would have the same name otherwise.","title":"Namespaces"},{"location":"namespaces/#general-case","text":"In most cases, you don't want to care about namespaces when parsing some XML. When you see foo:bar in XML elements or attributes, do as if the foo: prefix was not here, and everything should work as expected: <root xmlns:xs=\"http://example.com/xml/schema\"> <xs:item xs:type=\"text\">Hello, world!</xs:item> </root> >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield (node.attributes[\"type\"], node.text) >>> with open(\"hello_ns.xml\", \"rb\") as f: ... Parser(f).return_from(handler) ('text', 'Hello, world!')","title":"General case"},{"location":"namespaces/#namespaced-elements","text":"If you want to differentiate between XML elements with the same name but different namespaces, you need to mention namespaces in the handlers using the Clark notation . When parsing an XML element of name bar and namespace http://example.com/xml/schema , BigXML looks for a handler in the following order: {http://example.com/xml/schema}bar : a handler for the specific namespace bar : a handler that does not specify the namespace No handler is used, the element is ignored Tip To match only XML elements of name bar that do not have any namespace, use the following: {}bar . Example: <root xmlns=\"http://example.com/xml/purple\" xmlns:blue=\"http://example.com/xml/blue\" xmlns:red=\"http://example.com/xml/red\"> <blue:item>Blue</blue:item> <item xmlns=\"http://example.com/xml/blue\">Also blue</item> <red:item>Red</red:item> <item>Purple</item> </root> >>> @xml_handle_element(\"root\", \"item\") ... def handler_default(node): ... yield (\"default\", node.text) >>> @xml_handle_element(\"root\", \"{}item\") ... def handler_nothing(node): ... yield (\"nothing\", node.text) >>> @xml_handle_element(\"root\", \"{http://example.com/xml/blue}item\") ... def handler_blue(node): ... yield (\"blue\", node.text) >>> @xml_handle_element(\"root\", \"{http://example.com/xml/purple}item\") ... def handler_purple(node): ... yield (\"purple\", node.text) >>> with open(\"colors.xml\", \"rb\") as f: ... for item in Parser(f).iter_from( ... handler_default, ... handler_nothing, ... handler_blue, ... handler_purple, ... ): ... print(item) ('blue', 'Blue') ('blue', 'Also blue') ('default', 'Red') ('purple', 'Purple') Note In the example above, handler_purple is used instead of handler_nothing for the item Purple because a default namespace has been attached to <root> with the attribute xmlns .","title":"Namespaced elements"},{"location":"namespaces/#namespaced-attributes","text":"When accessing the attributes of a node, you can use one of the following keys: {http://example.com/xml/schema}bar to get the attribute bar with the namespace http://example.com/xml/schema ; {}bar to get the attribute bar without any namespace; bar to get an attribute bar of any namespace. Warning The bar syntax always returns the attribute bar without any namespace if it exists. However, if such an attribute does not exist but several attributes bar with various namespaces do exist, one of them will be returned. In that case, which attribute is returned is not guaranteed, and a warning is emitted accordingly. Example: <root xmlns=\"http://example.com/xml/purple\" xmlns:blue=\"http://example.com/xml/blue\" xmlns:red=\"http://example.com/xml/red\"> <item color=\"Green\">Case 0</item> <item blue:color=\"Blue\">Case 1</item> <item red:color=\"Red\">Case 2</item> <item color=\"Green\" blue:color=\"Blue\" red:color=\"Red\">Case 3</item> </root> >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield node.text ... yield (\"default ns\", node.attributes[\"color\"]) ... yield (\"no ns\", node.attributes.get(\"{}color\")) ... yield (\"blue ns\", node.attributes.get(\"{http://example.com/xml/blue}color\")) >>> with open(\"attributes_ns.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handler): ... print(item) Case 0 ('default ns', 'Green') ('no ns', 'Green') ('blue ns', None) Case 1 ('default ns', 'Blue') ('no ns', None) ('blue ns', 'Blue') Case 2 ('default ns', 'Red') ('no ns', None) ('blue ns', None) Case 3 ('default ns', 'Green') ('no ns', 'Green') ('blue ns', 'Blue') Note Contrary to XML elements, no default namespace apply to attributes: in the example, Green is matched by {}color instead of {http://example.com/xml/purple}color .","title":"Namespaced attributes"},{"location":"nodes/","text":"Nodes A node is the representation of an XML element or character data (i.e. text). They are passed as the argument to handlers functions. <p>Hello, world!</p> The XML document above has two nodes: An element node of name p ; A text node of text Hello, world! , whose parent if the previous node. XMLElement name The name of the element, without the namespace namespace The namespace of the element (or an empty string if no namespace ) attributes The attributes of the node as a dict -like object parents All parents of the node, in order, as a tuple of XMLElement instances iter_from , return_from Methods to handle the children of the node, same as Parser instances text A property to get a str representation of the text of the node Warning Using the text property parses all the children of the XML element until the closing element is found. As a result, you have to choose between calling iter_from , return_from , or accessing the text property, otherwise an exception will be raised. XMLText text The text of the node parents All parents of the node, in order, as a tuple of XMLElement instances","title":"Nodes"},{"location":"nodes/#nodes","text":"A node is the representation of an XML element or character data (i.e. text). They are passed as the argument to handlers functions. <p>Hello, world!</p> The XML document above has two nodes: An element node of name p ; A text node of text Hello, world! , whose parent if the previous node.","title":"Nodes"},{"location":"nodes/#xmlelement","text":"name The name of the element, without the namespace namespace The namespace of the element (or an empty string if no namespace ) attributes The attributes of the node as a dict -like object parents All parents of the node, in order, as a tuple of XMLElement instances iter_from , return_from Methods to handle the children of the node, same as Parser instances text A property to get a str representation of the text of the node Warning Using the text property parses all the children of the XML element until the closing element is found. As a result, you have to choose between calling iter_from , return_from , or accessing the text property, otherwise an exception will be raised.","title":"XMLElement"},{"location":"nodes/#xmltext","text":"text The text of the node parents All parents of the node, in order, as a tuple of XMLElement instances","title":"XMLText"},{"location":"parser/","text":"Parser The Parser class is the entry point for using BigXML . Instantiation Call Parser with any number of streams as arguments: Parser(stream0, stream1, ...) Each stream is consumed, in order, to get the raw XML data to be parsed. Methods iter_from Takes any number of handlers and returns an iterable whose items are generated by the handlers when the streams are parsed. return_from Just like iter_from , but returns the last item generated (or None if nothing is generated).","title":"Parser"},{"location":"parser/#parser","text":"The Parser class is the entry point for using BigXML .","title":"Parser"},{"location":"parser/#instantiation","text":"Call Parser with any number of streams as arguments: Parser(stream0, stream1, ...) Each stream is consumed, in order, to get the raw XML data to be parsed.","title":"Instantiation"},{"location":"parser/#methods","text":"iter_from Takes any number of handlers and returns an iterable whose items are generated by the handlers when the streams are parsed. return_from Just like iter_from , but returns the last item generated (or None if nothing is generated).","title":"Methods"},{"location":"quickstart/","text":"Quickstart Let's get started by parsing the atom feed of the XKCD comic , that should look similar to the following (which has been sightly modified for demonstration purposes): <?xml version=\"1.0\" encoding=\"utf-8\"?> <feed xmlns=\"http://www.w3.org/2005/Atom\" xml:lang=\"en\"> <title>xkcd.com</title> <link href=\"https://xkcd.com/\" rel=\"alternate\"></link> <id>https://xkcd.com/</id> <updated>2021-03-19T00:00:00Z</updated> <entry> <title>Solar System Cartogram</title> <link href=\"https://xkcd.com/2439/\" rel=\"alternate\"></link> <updated>2021-03-19T00:00:00Z</updated> <id>2439</id> </entry> <entry> <title>Siri</title> <link href=\"https://xkcd.com/2438/\" rel=\"alternate\"></link> <updated>2021-03-17T00:00:00Z</updated> <id>2438</id> </entry> <entry> <title>Post-Vaccine Party</title> <link href=\"https://xkcd.com/2437/\" rel=\"alternate\"></link> <updated>2021-03-15T00:00:00Z</updated> <id>2437</id> </entry> <entry> <title>Circles</title> <link href=\"https://xkcd.com/2436/\" rel=\"alternate\"></link> <updated>2021-03-12T00:00:00Z</updated> <id>2436</id> </entry> </feed> For this tutorial, save that into a atom.xml file (we will learn to parse HTTP responses in streaming later). Make sure you have BigXML installed so that you can follow along. Getting nodes and data Say we want to get the comics' titles. To do so, we will create a handler function. We pass the path to the title XML elements we are interested in as argument of the xml_handle_element decorator: >>> @xml_handle_element(\"feed\", \"entry\", \"title\") ... def handler(node): ... yield node.text # node contents as a str Next, we need to instantiate a Parser with a stream. In our case, we have the atom feed saved into a file, so we pass the file object. Finally, we call iter_from to obtain an iterator that will get though all the items yielded by the handler: >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handler): ... print(item) Solar System Cartogram Siri Post-Vaccine Party Circles Accessing attributes Now, we will get the link to the comics. This time, we are interested in the value of the href attribute of the link elements: >>> @xml_handle_element(\"feed\", \"entry\", \"link\") ... def handler(node): ... yield node.attributes[\"href\"] The rest of the code works as expected: >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handler): ... print(item) https://xkcd.com/2439/ https://xkcd.com/2438/ https://xkcd.com/2437/ https://xkcd.com/2436/ Combining handlers But what if we want both title and links? We can do the following: Create handlers for title and link children of a entry element; Call those two handlers from a third handler that takes care of entry elements. >>> @xml_handle_element(\"title\") ... def handle_title(node): ... yield node.text >>> @xml_handle_element(\"link\") ... def handle_link(node): ... yield node.attributes[\"href\"] >>> @xml_handle_element(\"feed\", \"entry\") ... def handle_entry(node): ... yield 'new entry' ... yield from node.iter_from(handle_title, handle_link) Note The xml_handle_element decorators for handle_title and handle_link use a path starting from the entry element, since these handlers are passed to the iter_from method of an entry node. >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handle_entry): ... print(item) new entry Solar System Cartogram https://xkcd.com/2439/ new entry Siri https://xkcd.com/2438/ new entry Post-Vaccine Party https://xkcd.com/2437/ new entry Circles https://xkcd.com/2436/ We are not really satisfied with the result: it is not really possible to differentiate between titles and links of comics, because all we get from calling Parser(f).iter_from(handle_entry) are strings. Also, it is not easy to see which link is for which title. Ideally, we would like to group each entry into an object to be able to work on it. Using dataclasses is quite natural to do so: >>> from dataclasses import dataclass >>> @xml_handle_element(\"feed\", \"entry\") ... @dataclass ... class Entry: ... title: str = 'N/A' ... link: str = 'N/A' ... ... @xml_handle_element(\"title\") ... def handle_title(self, node): ... self.title = node.text ... ... @xml_handle_element(\"link\") ... def handle_link(self, node): ... self.link = node.attributes[\"href\"] >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(Entry): ... print(item) Entry(title='Solar System Cartogram', link='https://xkcd.com/2439/') Entry(title='Siri', link='https://xkcd.com/2438/') Entry(title='Post-Vaccine Party', link='https://xkcd.com/2437/') Entry(title='Circles', link='https://xkcd.com/2436/')","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"Let's get started by parsing the atom feed of the XKCD comic , that should look similar to the following (which has been sightly modified for demonstration purposes): <?xml version=\"1.0\" encoding=\"utf-8\"?> <feed xmlns=\"http://www.w3.org/2005/Atom\" xml:lang=\"en\"> <title>xkcd.com</title> <link href=\"https://xkcd.com/\" rel=\"alternate\"></link> <id>https://xkcd.com/</id> <updated>2021-03-19T00:00:00Z</updated> <entry> <title>Solar System Cartogram</title> <link href=\"https://xkcd.com/2439/\" rel=\"alternate\"></link> <updated>2021-03-19T00:00:00Z</updated> <id>2439</id> </entry> <entry> <title>Siri</title> <link href=\"https://xkcd.com/2438/\" rel=\"alternate\"></link> <updated>2021-03-17T00:00:00Z</updated> <id>2438</id> </entry> <entry> <title>Post-Vaccine Party</title> <link href=\"https://xkcd.com/2437/\" rel=\"alternate\"></link> <updated>2021-03-15T00:00:00Z</updated> <id>2437</id> </entry> <entry> <title>Circles</title> <link href=\"https://xkcd.com/2436/\" rel=\"alternate\"></link> <updated>2021-03-12T00:00:00Z</updated> <id>2436</id> </entry> </feed> For this tutorial, save that into a atom.xml file (we will learn to parse HTTP responses in streaming later). Make sure you have BigXML installed so that you can follow along.","title":"Quickstart"},{"location":"quickstart/#getting-nodes-and-data","text":"Say we want to get the comics' titles. To do so, we will create a handler function. We pass the path to the title XML elements we are interested in as argument of the xml_handle_element decorator: >>> @xml_handle_element(\"feed\", \"entry\", \"title\") ... def handler(node): ... yield node.text # node contents as a str Next, we need to instantiate a Parser with a stream. In our case, we have the atom feed saved into a file, so we pass the file object. Finally, we call iter_from to obtain an iterator that will get though all the items yielded by the handler: >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handler): ... print(item) Solar System Cartogram Siri Post-Vaccine Party Circles","title":"Getting nodes and data"},{"location":"quickstart/#accessing-attributes","text":"Now, we will get the link to the comics. This time, we are interested in the value of the href attribute of the link elements: >>> @xml_handle_element(\"feed\", \"entry\", \"link\") ... def handler(node): ... yield node.attributes[\"href\"] The rest of the code works as expected: >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handler): ... print(item) https://xkcd.com/2439/ https://xkcd.com/2438/ https://xkcd.com/2437/ https://xkcd.com/2436/","title":"Accessing attributes"},{"location":"quickstart/#combining-handlers","text":"But what if we want both title and links? We can do the following: Create handlers for title and link children of a entry element; Call those two handlers from a third handler that takes care of entry elements. >>> @xml_handle_element(\"title\") ... def handle_title(node): ... yield node.text >>> @xml_handle_element(\"link\") ... def handle_link(node): ... yield node.attributes[\"href\"] >>> @xml_handle_element(\"feed\", \"entry\") ... def handle_entry(node): ... yield 'new entry' ... yield from node.iter_from(handle_title, handle_link) Note The xml_handle_element decorators for handle_title and handle_link use a path starting from the entry element, since these handlers are passed to the iter_from method of an entry node. >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(handle_entry): ... print(item) new entry Solar System Cartogram https://xkcd.com/2439/ new entry Siri https://xkcd.com/2438/ new entry Post-Vaccine Party https://xkcd.com/2437/ new entry Circles https://xkcd.com/2436/ We are not really satisfied with the result: it is not really possible to differentiate between titles and links of comics, because all we get from calling Parser(f).iter_from(handle_entry) are strings. Also, it is not easy to see which link is for which title. Ideally, we would like to group each entry into an object to be able to work on it. Using dataclasses is quite natural to do so: >>> from dataclasses import dataclass >>> @xml_handle_element(\"feed\", \"entry\") ... @dataclass ... class Entry: ... title: str = 'N/A' ... link: str = 'N/A' ... ... @xml_handle_element(\"title\") ... def handle_title(self, node): ... self.title = node.text ... ... @xml_handle_element(\"link\") ... def handle_link(self, node): ... self.link = node.attributes[\"href\"] >>> with open(\"atom.xml\", \"rb\") as f: ... for item in Parser(f).iter_from(Entry): ... print(item) Entry(title='Solar System Cartogram', link='https://xkcd.com/2439/') Entry(title='Siri', link='https://xkcd.com/2438/') Entry(title='Post-Vaccine Party', link='https://xkcd.com/2437/') Entry(title='Circles', link='https://xkcd.com/2436/')","title":"Combining handlers"},{"location":"recipes/","text":"Recipes Working with Requests Requests is a library that simplifies making HTTP requests. It is easy to stream an XML response from a server and parse it on the fly: When creating the request, specify stream=True so that the content is downloaded as needed if the server supports it; Instead of getting the content from the response at once, use Response.iter_content to iterate over the response data in chunks. >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield node.text >>> response = requests.get(\"https://www.example.com/placeholder.xml\", stream=True) >>> parser = Parser(response.iter_content(1 << 14)) >>> for item in parser.iter_from(handler): ... print(item) This example shows parsing in streaming with Requests. It works quite well! Performance optimizations The number passed to Response.iter_content is the chunk size, which is the maximum number of bytes that will be obtained at a time. This specific value of 1 << 14 is the one used under the hood by BigXML 's parsing library. Although any size would work, use anything between 1kb and 1Mb for best results. Dataclasses Although not mandatory, using a dataclass may seem natural to hold the parsed data: <users> <user id=\"13\"> <firstname>Alice</firstname> <lastname>Cooper</lastname> </user> <user id=\"37\"> <firstname>Bob</firstname> <lastname>Marley</lastname> </user> <user id=\"42\"> <firstname>Carol</firstname> </user> </users> >>> from dataclasses import dataclass >>> @xml_handle_element(\"users\", \"user\") ... @dataclass ... class User: ... firstname: str = 'N/A' ... lastname: str = 'N/A' ... ... @xml_handle_element(\"firstname\") ... def handle_firstname(self, node): ... self.firstname = node.text ... ... @xml_handle_element(\"lastname\") ... def handle_lastname(self, node): ... self.lastname = node.text >>> with open(\"users.xml\", \"rb\") as stream: ... for user in Parser(stream).iter_from(User): ... print(user) User(firstname='Alice', lastname='Cooper') User(firstname='Bob', lastname='Marley') User(firstname='Carol', lastname='N/A') Warning All fields of the dataclass must have a default value. If you need to get information from the node handled by the dataclass, you can do so in the __post_init__ method: >>> from dataclasses import dataclass, InitVar >>> @xml_handle_element(\"users\", \"user\") ... @dataclass ... class User: ... node: InitVar ... id: int = 0 ... firstname: str = 'N/A' ... lastname: str = 'N/A' ... ... def __post_init__(self, node): ... self.id = int(node.attributes['id']) ... ... @xml_handle_element(\"firstname\") ... def handle_firstname(self, node): ... self.firstname = node.text ... ... @xml_handle_element(\"lastname\") ... def handle_lastname(self, node): ... self.lastname = node.text >>> with open(\"users.xml\", \"rb\") as stream: ... for user in Parser(stream).iter_from(User): ... print(user) User(id=13, firstname='Alice', lastname='Cooper') User(id=37, firstname='Bob', lastname='Marley') User(id=42, firstname='Carol', lastname='N/A') Warning The node attribute is an InitVar , so that it is passed to __post_init__ but not stored in class attributes. It must be the only mandatory field, since the class is automatically instantiated with only one argument (the node). For more details, see class handlers . Yielding data in a class __init__ If you use a class handler , you may want to yield some data when the class starts or ends to parse nodes. Of course, it is not possible to use the yield keyword in __init__ : >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... yield f\"START cart parsing for user {node.attributes['user']}\" >>> with open(\"carts.xml\", \"rb\") as stream: ... for item in Parser(stream).iter_from(Cart): ... print(item) Traceback (most recent call last): ... TypeError: __init__() should return None... Instead, you can define a custom xml_handler method: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... self.user = node.attributes[\"user\"] ... ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... yield f\"product: {node.text}\" ... ... def xml_handler(self, items): ... yield f\"START cart parsing for user {self.user}\" ... yield from items ... yield f\"END cart parsing for user {self.user}\" >>> with open(\"carts.xml\", \"rb\") as stream: ... for item in Parser(stream).iter_from(Cart): ... print(item) START cart parsing for user Alice product: 9781846975769 product: 9780008322052 END cart parsing for user Alice START cart parsing for user Bob product: 9780008117498 product: 9780340960196 product: 9780099580485 END cart parsing for user Bob Streams without root In some cases, you may be parsing a stream of XML elements that follow each other without starting with a common root. For example, let's say a software outputs the following log file: <log level=\"WARN\">Main reactor overheat</log> <log level=\"INFO\">Starting emergency coolers</log> <log level=\"DEBUG\">Cooler 4 is online</log> <log level=\"DEBUG\">Cooler 2 is online</log> <log level=\"INFO\">Main reactor temperature is back to an acceptable level</log> We can just wrap the stream in an XML element: >>> @xml_handle_element(\"root\", \"log\") ... def handler(node): ... yield f\"{node.attributes['level']:5} {node.text}\" >>> with open(\"log.xml\", \"rb\") as stream: ... parser = Parser(b\"<root>\", stream, b\"</root>\") ... for item in parser.iter_from(handler): ... print(item) WARN Main reactor overheat INFO Starting emergency coolers DEBUG Cooler 4 is online DEBUG Cooler 2 is online INFO Main reactor temperature is back to an acceptable level Infinite streams Infinite streams are supported through file-like objects and iterables. Here is an example using an infinite generator function as a stream: >>> def collatz_generator(value): ... yield b\"<root>\" ... while True: ... yield b\"<item>%d</item>\" % value ... if value % 2: ... value = 3 * value + 1 ... else: ... value //= 2 >>> stream = collatz_generator(42) >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield int(node.text) >>> items = Parser(stream).iter_from(handler) >>> for _ in range(12): ... print(next(items)) 42 21 64 32 16 8 4 2 1 4 2 1","title":"Recipes"},{"location":"recipes/#recipes","text":"","title":"Recipes"},{"location":"recipes/#requests","text":"Requests is a library that simplifies making HTTP requests. It is easy to stream an XML response from a server and parse it on the fly: When creating the request, specify stream=True so that the content is downloaded as needed if the server supports it; Instead of getting the content from the response at once, use Response.iter_content to iterate over the response data in chunks. >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield node.text >>> response = requests.get(\"https://www.example.com/placeholder.xml\", stream=True) >>> parser = Parser(response.iter_content(1 << 14)) >>> for item in parser.iter_from(handler): ... print(item) This example shows parsing in streaming with Requests. It works quite well! Performance optimizations The number passed to Response.iter_content is the chunk size, which is the maximum number of bytes that will be obtained at a time. This specific value of 1 << 14 is the one used under the hood by BigXML 's parsing library. Although any size would work, use anything between 1kb and 1Mb for best results.","title":"Working with Requests"},{"location":"recipes/#dataclass","text":"Although not mandatory, using a dataclass may seem natural to hold the parsed data: <users> <user id=\"13\"> <firstname>Alice</firstname> <lastname>Cooper</lastname> </user> <user id=\"37\"> <firstname>Bob</firstname> <lastname>Marley</lastname> </user> <user id=\"42\"> <firstname>Carol</firstname> </user> </users> >>> from dataclasses import dataclass >>> @xml_handle_element(\"users\", \"user\") ... @dataclass ... class User: ... firstname: str = 'N/A' ... lastname: str = 'N/A' ... ... @xml_handle_element(\"firstname\") ... def handle_firstname(self, node): ... self.firstname = node.text ... ... @xml_handle_element(\"lastname\") ... def handle_lastname(self, node): ... self.lastname = node.text >>> with open(\"users.xml\", \"rb\") as stream: ... for user in Parser(stream).iter_from(User): ... print(user) User(firstname='Alice', lastname='Cooper') User(firstname='Bob', lastname='Marley') User(firstname='Carol', lastname='N/A') Warning All fields of the dataclass must have a default value. If you need to get information from the node handled by the dataclass, you can do so in the __post_init__ method: >>> from dataclasses import dataclass, InitVar >>> @xml_handle_element(\"users\", \"user\") ... @dataclass ... class User: ... node: InitVar ... id: int = 0 ... firstname: str = 'N/A' ... lastname: str = 'N/A' ... ... def __post_init__(self, node): ... self.id = int(node.attributes['id']) ... ... @xml_handle_element(\"firstname\") ... def handle_firstname(self, node): ... self.firstname = node.text ... ... @xml_handle_element(\"lastname\") ... def handle_lastname(self, node): ... self.lastname = node.text >>> with open(\"users.xml\", \"rb\") as stream: ... for user in Parser(stream).iter_from(User): ... print(user) User(id=13, firstname='Alice', lastname='Cooper') User(id=37, firstname='Bob', lastname='Marley') User(id=42, firstname='Carol', lastname='N/A') Warning The node attribute is an InitVar , so that it is passed to __post_init__ but not stored in class attributes. It must be the only mandatory field, since the class is automatically instantiated with only one argument (the node). For more details, see class handlers .","title":"Dataclasses"},{"location":"recipes/#yield-in-init","text":"If you use a class handler , you may want to yield some data when the class starts or ends to parse nodes. Of course, it is not possible to use the yield keyword in __init__ : >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... yield f\"START cart parsing for user {node.attributes['user']}\" >>> with open(\"carts.xml\", \"rb\") as stream: ... for item in Parser(stream).iter_from(Cart): ... print(item) Traceback (most recent call last): ... TypeError: __init__() should return None... Instead, you can define a custom xml_handler method: >>> @xml_handle_element(\"root\", \"cart\") ... class Cart: ... def __init__(self, node): ... self.user = node.attributes[\"user\"] ... ... @xml_handle_element(\"product\") ... def handle_product(self, node): ... yield f\"product: {node.text}\" ... ... def xml_handler(self, items): ... yield f\"START cart parsing for user {self.user}\" ... yield from items ... yield f\"END cart parsing for user {self.user}\" >>> with open(\"carts.xml\", \"rb\") as stream: ... for item in Parser(stream).iter_from(Cart): ... print(item) START cart parsing for user Alice product: 9781846975769 product: 9780008322052 END cart parsing for user Alice START cart parsing for user Bob product: 9780008117498 product: 9780340960196 product: 9780099580485 END cart parsing for user Bob","title":"Yielding data in a class __init__"},{"location":"recipes/#no-root","text":"In some cases, you may be parsing a stream of XML elements that follow each other without starting with a common root. For example, let's say a software outputs the following log file: <log level=\"WARN\">Main reactor overheat</log> <log level=\"INFO\">Starting emergency coolers</log> <log level=\"DEBUG\">Cooler 4 is online</log> <log level=\"DEBUG\">Cooler 2 is online</log> <log level=\"INFO\">Main reactor temperature is back to an acceptable level</log> We can just wrap the stream in an XML element: >>> @xml_handle_element(\"root\", \"log\") ... def handler(node): ... yield f\"{node.attributes['level']:5} {node.text}\" >>> with open(\"log.xml\", \"rb\") as stream: ... parser = Parser(b\"<root>\", stream, b\"</root>\") ... for item in parser.iter_from(handler): ... print(item) WARN Main reactor overheat INFO Starting emergency coolers DEBUG Cooler 4 is online DEBUG Cooler 2 is online INFO Main reactor temperature is back to an acceptable level","title":"Streams without root"},{"location":"recipes/#infinite-streams","text":"Infinite streams are supported through file-like objects and iterables. Here is an example using an infinite generator function as a stream: >>> def collatz_generator(value): ... yield b\"<root>\" ... while True: ... yield b\"<item>%d</item>\" % value ... if value % 2: ... value = 3 * value + 1 ... else: ... value //= 2 >>> stream = collatz_generator(42) >>> @xml_handle_element(\"root\", \"item\") ... def handler(node): ... yield int(node.text) >>> items = Parser(stream).iter_from(handler) >>> for _ in range(12): ... print(next(items)) 42 21 64 32 16 8 4 2 1 4 2 1","title":"Infinite streams"},{"location":"streams/","text":"Streams A stream is an object that can be passed as an argument to Parser . It represents the raw XML data to be parsed. File-like objects Files open in binary mode , io.BytesIO , etc. <root>Hello, world!</root> >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> with open(\"hello.xml\", \"rb\") as stream: ... Parser(stream).return_from(handler) 'Hello, world!' Bytes-like objects bytes , bytearray , memoryview , etc. >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> stream = b\"<root>Hello, world!</root>\" >>> Parser(stream).return_from(handler) 'Hello, world!' Iterables Any iterable whose items are streams : lists, generators, etc. >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> def generate_stream(): ... yield b\"<root>\" ... yield b\"Hello, world!\" ... yield b\"</root>\" >>> stream = generate_stream() >>> Parser(stream).return_from(handler) 'Hello, world!' Examples include: HTTP streaming with Requests Infinite stream Note You can pass any number of streams to Parser , so the following are equivalent: Parser([stream0, stream1, stream2]) Parser(stream0, stream1, stream2)","title":"Streams"},{"location":"streams/#streams","text":"A stream is an object that can be passed as an argument to Parser . It represents the raw XML data to be parsed.","title":"Streams"},{"location":"streams/#file-like-objects","text":"Files open in binary mode , io.BytesIO , etc. <root>Hello, world!</root> >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> with open(\"hello.xml\", \"rb\") as stream: ... Parser(stream).return_from(handler) 'Hello, world!'","title":"File-like objects"},{"location":"streams/#bytes-like-objects","text":"bytes , bytearray , memoryview , etc. >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> stream = b\"<root>Hello, world!</root>\" >>> Parser(stream).return_from(handler) 'Hello, world!'","title":"Bytes-like objects"},{"location":"streams/#iterables","text":"Any iterable whose items are streams : lists, generators, etc. >>> @xml_handle_element(\"root\") ... def handler(node): ... yield node.text >>> def generate_stream(): ... yield b\"<root>\" ... yield b\"Hello, world!\" ... yield b\"</root>\" >>> stream = generate_stream() >>> Parser(stream).return_from(handler) 'Hello, world!' Examples include: HTTP streaming with Requests Infinite stream Note You can pass any number of streams to Parser , so the following are equivalent: Parser([stream0, stream1, stream2]) Parser(stream0, stream1, stream2)","title":"Iterables"}]}